<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,maximum-scale=1,user-scalable=no" />
<title>Orthochromatic Camera â€” iOS fix</title>
<style>
  html,body{margin:0;height:100%;background:#000}
  /* Keep <video> in DOM and "visible" to WebKit, but offscreen/inert */
  #vid{
    position:fixed; left:-9999px; top:-9999px;
    width:1px; height:1px; opacity:0; pointer-events:none;
  }
  canvas{width:100vw;height:100vh;display:block}
  .frame{position:fixed;inset:0;pointer-events:none;box-shadow:inset 0 0 120px 40px rgba(0,0,0,.9);border:14px solid #000}
  #ui{position:fixed;left:8px;top:8px;display:flex;gap:8px;z-index:1000}
  button,select{font:14px system-ui,sans-serif;padding:.6em .8em;border:0;border-radius:10px}
  #start{background:#fff}
  #flip,#stutter{background:#222;color:#ddd}
  #fpscap{background:#222;color:#ddd}
  #err{position:fixed;left:8px;bottom:8px;max-width:90vw;color:#f55;font:12px ui-monospace,monospace;white-space:pre-wrap;background:rgba(0,0,0,.6);padding:6px 8px;border-radius:8px;z-index:1001}
</style>
</head>
<body>
<video id="vid" playsinline muted></video>
<canvas id="stage"></canvas>
<div class="frame"></div>

<div id="ui">
  <button id="start">Enable camera</button>
  <button id="flip" disabled>Flip camera</button>
  <button id="stutter" disabled data-on="0">Stutter: off</button>
  <select id="fpscap" disabled title="Cap draw FPS (0 = uncapped)">
    <option value="0" selected>FPS cap: 0</option>
    <option value="30">30</option>
    <option value="24">24</option>
    <option value="16">16</option>
  </select>
</div>
<div id="err"></div>

<script>
(function(){
  const $=id=>document.getElementById(id);
  const video=$('vid'), canvas=$('stage');
  const startBtn=$('start'), flipBtn=$('flip'), stutterBtn=$('stutter'), fpsCapSel=$('fpscap'), errBox=$('err');

  let facing='environment', stream=null, running=false;
  let useWebGL=false, gl=null, program=null, tex=null, u={}, ctx2d=null;

  function note(m){ errBox.textContent=m; }
  function clearNote(){ errBox.textContent=''; }

  function resize(){
    const dpr=Math.max(1,Math.min(3,window.devicePixelRatio||1));
    const w=Math.floor(innerWidth*dpr), h=Math.floor(innerHeight*dpr);
    canvas.width=w; canvas.height=h;
    if(useWebGL && gl){ gl.viewport(0,0,w,h); gl.uniform2f(u.resolution,w,h); }
  }
  addEventListener('resize',resize,{passive:true});

  // ---- WebGL (same shader as before) --------------------------------------
  function initWebGL(){
    try{
      gl=canvas.getContext('webgl',{antialias:false,preserveDrawingBuffer:false});
      if(!gl) return false;
      const vs=`attribute vec2 a_pos,a_uv;varying vec2 v_uv;void main(){v_uv=a_uv;gl_Position=vec4(a_pos,0.,1.);}`;
      const fs=`precision mediump float;varying vec2 v_uv;uniform sampler2D tex0;uniform vec2 resolution;uniform float time,yellow,grain,vignette,gate,stutterSteps;uniform vec3 orthoMix;
float s2l(float u){return (u<=0.04045)?u/12.92:pow((u+0.055)/1.055,2.4);} float l2s(float u){return (u<=0.0031308)?12.92*u:1.055*pow(u,1.0/2.4)-0.055;}
vec3 s2l3(vec3 c){return vec3(s2l(c.r),s2l(c.g),s2l(c.b));}
float filmic(float x){x=clamp(x,0.,1.);float a=.22,b=.3,c=.1,d=.2,e=.01,f=.3;return ((x*(a*x+c*b)+d*e)/(x*(a*x+b)+d*f))-e/f;}
float h(vec2 p){p=vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3)));return -1.+2.*fract(sin(p)*43758.5453);}
void main(){
  float t=time; if(stutterSteps>0.){float s=1./stutterSteps; t=floor(time/s)*s;}
  vec2 px=1./resolution;
  vec2 uv=v_uv+vec2(h(vec2(t*13.1,7.7))*gate*px.x,h(vec2(t*9.3,5.2))*gate*px.y);
  vec3 s=texture2D(tex0,uv).rgb; s=s2l3(s); s.b*=1.-yellow;
  float y=dot(s,orthoMix);
  float redness=max(0.,s.r-max(s.g,s.b)); y=max(0.,y-redness*.08);
  y=filmic(y); y=clamp(y+h(uv*vec2(1024.,768.)+t*37.)*grain,0.,1.);
  float ys=l2s(y);
  vec2 p=gl_FragCoord.xy/resolution; float r=distance(p,vec2(.5)); float vig=smoothstep(.9,.5,1.-r); float vMix=mix(1.,vig,vignette);
  gl_FragColor=vec4(vec3(ys)*vMix,1.);
}}`;
      function sh(t,s){const o=gl.createShader(t);gl.shaderSource(o,s);gl.compileShader(o);if(!gl.getShaderParameter(o,gl.COMPILE_STATUS))throw new Error(gl.getShaderInfoLog(o));return o;}
      program=gl.createProgram(); gl.attachShader(program,sh(gl.VERTEX_SHADER,vs)); gl.attachShader(program,sh(gl.FRAGMENT_SHADER,fs)); gl.linkProgram(program);
      if(!gl.getProgramParameter(program,gl.LINK_STATUS)) throw new Error(gl.getProgramInfoLog(program)); gl.useProgram(program);
      const quad=new Float32Array([-1,-1,1,-1,-1,1, 1,-1,1,1,-1,1]);
      const uvs=new Float32Array([0,0,1,0,0,1, 1,0,1,1,0,1]);
      const b1=gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER,b1); gl.bufferData(gl.ARRAY_BUFFER,quad,gl.STATIC_DRAW);
      const a_pos=gl.getAttribLocation(program,'a_pos'); gl.enableVertexAttribArray(a_pos); gl.vertexAttribPointer(a_pos,2,gl.FLOAT,false,0,0);
      const b2=gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER,b2); gl.bufferData(gl.ARRAY_BUFFER,uvs,gl.STATIC_DRAW);
      const a_uv=gl.getAttribLocation(program,'a_uv'); gl.enableVertexAttribArray(a_uv); gl.vertexAttribPointer(a_uv,2,gl.FLOAT,false,0,0);
      tex=gl.createTexture(); gl.bindTexture(gl.TEXTURE_2D,tex);
      gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.LINEAR); gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl.CLAMP_TO_EDGE); gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl.CLAMP_TO_EDGE);
      function U(n){return gl.getUniformLocation(program,n);}
      u.time=U('time'); u.resolution=U('resolution'); u.yellow=U('yellow'); u.grain=U('grain'); u.vignette=U('vignette'); u.gate=U('gate'); u.orthoMix=U('orthoMix'); u.stutterSteps=U('stutterSteps');
      gl.uniform1i(gl.getUniformLocation(program,'tex0'),0);
      gl.uniform1f(u.yellow,0.10); gl.uniform1f(u.grain,0.08); gl.uniform1f(u.vignette,0.55); gl.uniform1f(u.gate,2.0);
      gl.uniform3f(u.orthoMix,0.06,0.62,0.32); gl.uniform1f(u.stutterSteps,0.0);
      useWebGL=true; resize(); return true;
    }catch(e){ note('WebGL init failed: '+e.message); useWebGL=false; return false; }
  }

  function init2D(){ ctx2d=canvas.getContext('2d',{willReadFrequently:true}); useWebGL=false; resize(); }

  async function startStream(){
    try{
      if(stream) stream.getTracks().forEach(t=>t.stop());
      // Recreate <video> attributes every start (iOS is picky)
      video.muted=true; video.playsInline=true; video.setAttribute('playsinline','');
      stream=await navigator.mediaDevices.getUserMedia({
        video:{ facingMode:facing, width:{ideal:1920}, height:{ideal:1080}, frameRate:{ideal:60,max:60} },
        audio:false
      });
      video.srcObject=stream;

      // Wait for actual frames. iOS often reports active before dimensions exist.
      await video.play();
      await waitForDimensions();
      clearNote();
    }catch(e){
      note('Camera error: '+(e.message||e.name));
      throw e;
    }
  }

  function waitForDimensions(){
    return new Promise((resolve,reject)=>{
      const t0=performance.now();
      function check(){
        if(video.readyState>=2 && video.videoWidth>0 && video.videoHeight>0) return resolve();
        if(performance.now()-t0>5000) return reject(new Error('Video never produced frames'));
        requestAnimationFrame(check);
      }
      check();
    });
  }

  let lastDraw=0;
  function drawGL(now){
    if(!running) return;
    const cap=parseInt(fpsCapSel.value,10);
    if(cap>0){
      const min=1000/cap;
      if(now-lastDraw<min){ requestAnimationFrame(drawGL); return; }
      lastDraw=now;
    }
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D,tex);
    try{ gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,gl.RGBA,gl.UNSIGNED_BYTE,video); }catch(_){}
    gl.uniform1f(u.time,now/1000);
    gl.drawArrays(gl.TRIANGLES,0,6);
    requestAnimationFrame(drawGL);
  }

  function draw2D(){
    if(!running) return;
    const w=canvas.width,h=canvas.height;
    const vw=video.videoWidth||1280,vh=video.videoHeight||720;
    const vR=vw/vh, cR=w/h;
    let dw,dh,dx,dy; if(vR>cR){dh=h;dw=dh*vR;dx=(w-dw)/2;dy=0;}else{dw=w;dh=dw/vR;dx=0;dy=(h-dh)/2;}
    ctx2d.drawImage(video,dx,dy,dw,dh);
    // quick ortho grayscale in fallback
    const img=ctx2d.getImageData(0,0,w,h), d=img.data;
    for(let i=0;i<d.length;i+=4){ const y=0.06*d[i]+0.62*d[i+1]+0.32*d[i+2]; d[i]=d[i+1]=d[i+2]=y; }
    ctx2d.putImageData(img,0,0);
    requestAnimationFrame(draw2D);
  }

  // Bind events first
  startBtn.addEventListener('click', async ()=>{
    try{
      if(!gl && !ctx2d){ if(!initWebGL()) init2D(); }
      await startStream();
      running=true;
      flipBtn.disabled=false;
      stutterBtn.disabled=!useWebGL;
      fpsCapSel.disabled=false;
      if(useWebGL) requestAnimationFrame(drawGL); else requestAnimationFrame(draw2D);
    }catch(_){}
  }, {passive:true});

  flipBtn.addEventListener('click', async ()=>{
    try{ facing=(facing==='environment')?'user':'environment'; await startStream(); }catch(_){}
  }, {passive:true});

  stutterBtn.addEventListener('click', ()=>{
    if(!useWebGL) return;
    const on=stutterBtn.getAttribute('data-on')==='1'; const next=on?'0':'1';
    stutterBtn.setAttribute('data-on',next); stutterBtn.textContent=`Stutter: ${next==='1'?'on':'off'}`;
    gl.uniform1f(u.stutterSteps,next==='1'?16.0:0.0);
  }, {passive:true});

  document.addEventListener('visibilitychange',()=>{
    if(document.hidden && stream){ stream.getTracks().forEach(t=>t.stop()); running=false; }
  });

  resize();
})();
</script>
</body>
</html>