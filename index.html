<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Orthochromatic Camera</title>
<style>
  html,body { margin:0; height:100%; background:#000; }
  canvas { width:100vw; height:100vh; display:block; }
  #start {
    position: fixed; left:50%; top:50%; transform:translate(-50%,-50%);
    font:16px system-ui,sans-serif; padding:.9em 1.2em; border:0; border-radius:10px;
    background:#fff; color:#000;
  }
  .frame { position:fixed; inset:0; pointer-events:none; box-shadow: inset 0 0 120px 40px rgba(0,0,0,0.9); border: 14px solid #000; }
  .badge { position:fixed; right:8px; bottom:6px; color:#aaa; font:12px/1.2 ui-monospace,monospace; opacity:.6; background: rgba(0,0,0,.4); padding:3px 6px; border-radius:4px; }
</style>
</head>
<body>
<button id="start">Enable Camera</button>
<canvas id="c"></canvas>
<div class="frame"></div>
<div class="badge">Orthochromatic emulation</div>

<script>
(async function () {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { willReadFrequently: true });
  const startBtn = document.getElementById('start');
  let video, stream, running = false;

  function resize() {
    const dpr = Math.max(1, Math.min(3, devicePixelRatio || 1));
    canvas.width  = Math.floor(innerWidth  * dpr);
    canvas.height = Math.floor(innerHeight * dpr);
  }
  addEventListener('resize', resize, { passive:true });
  resize();

  let seed = 1;
  function rand() { seed = (seed * 16807) % 2147483647; return (seed - 1) / 2147483646; }

  async function start() {
    if (running) return;
    startBtn.remove();

    video = document.createElement('video');
    video.setAttribute('playsinline', 'true');
    video.muted = true; video.autoplay = true;

    try {
      stream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode: { ideal: 'environment' }, width:{ ideal:1280 }, height:{ ideal:720 } },
        audio: false
      });
    } catch (e) {
      alert('Camera permission failed or unavailable.'); return;
    }

    video.srcObject = stream;
    await video.play();
    running = true;
    requestAnimationFrame(loop);
  }

  const targetMs = 1000/16; // ~16 fps stutter
  let last = 0;

  // Filmic S-curve (contrast with preserved toe/shoulder).
  function filmic(y) {
    // y in [0,1]; curve parameters tuned for punchy B/W without clipping faces
    const a=0.22, b=0.3, c=0.1, d=0.2, e=0.01, f=0.3;
    return ((y*(a*y+c*b)+d*e)/(y*(a*y+b)+d*f))-e/f;
  }

  // sRGB <-> linear helpers (approx)
  function srgbToLinear(u){ u/=255; return u<=0.04045? u/12.92 : Math.pow((u+0.055)/1.055,2.4); }
  function linearToSrgb(u){ return u<=0.0031308? 12.92*u : 1.055*Math.pow(u,1/2.4)-0.055; }

  function loop(ts=0) {
    if (!running) return;
    if (ts - last < targetMs) return requestAnimationFrame(loop);
    last = ts;

    const cw = canvas.width, ch = canvas.height;
    const vw = video.videoWidth || 1280, vh = video.videoHeight || 720;
    const vR = vw/vh, cR = cw/ch;
    let dw, dh, dx, dy;
    if (vR > cR) { dh = ch; dw = dh * vR; dx = (cw - dw)/2; dy = 0; }
    else { dw = cw; dh = dw / vR; dx = 0; dy = (ch - dh)/2; }

    const jitter = Math.floor((rand()-0.5) * 4);
    ctx.drawImage(video, dx + jitter, dy + jitter, dw, dh);

    const img = ctx.getImageData(0,0,cw,ch);
    const d = img.data;

    // Orthochromatic grayscale:
    // Downweight red heavily; boost green moderately; keep strong blue.
    // Coeffs approximate early-1900s ortho stock spectral bias.
    // Normalize after gamma-correct mixing.
    const rW = 0.06, gW = 0.62, bW = 0.32; // sum = 1

    for (let i=0; i<d.length; i+=4) {
      // Convert to linear light
      let r = srgbToLinear(d[i]);
      let g = srgbToLinear(d[i+1]);
      let b = srgbToLinear(d[i+2]);

      // Optional yellow filter to tame sky (like a lens filter) — comment to disable
      // This gently reduces blue pre-mix
      const yellowFilter = 0.1; // 0..0.25
      b = b*(1 - yellowFilter);

      // Ortho mix → luminance
      let y = r*rW + g*gW + b*bW;

      // Mild ortho “blue lift / red crush” nonlinearity
      // extra pull-down on red-rich values (approximate via chroma proxy)
      const redness = Math.max(0, r - Math.max(g,b));
      y -= redness * 0.08; // deepen reds a bit more

      // Filmic S-curve
      y = filmic(Math.min(1, Math.max(0, y)));

      // Add grain in linear domain
      const n = (rand()-0.5)*0.095; // grain strength
      y = Math.min(1, Math.max(0, y + n));

      // Back to sRGB
      const ys = Math.round(255 * linearToSrgb(y));
      d[i] = d[i+1] = d[i+2] = ys;
      // keep alpha
    }
    ctx.putImageData(img,0,0);

    // Vignette
    const grad = ctx.createRadialGradient(cw/2, ch/2, Math.min(cw,ch)*0.2, cw/2, ch/2, Math.max(cw,ch)*0.62);
    grad.addColorStop(0, 'rgba(0,0,0,0)');
    grad.addColorStop(1, 'rgba(0,0,0,0.55)');
    ctx.fillStyle = grad; ctx.fillRect(0,0,cw,ch);

    requestAnimationFrame(loop);
  }

  startBtn.addEventListener('click', start, { passive:true });

  document.addEventListener('visibilitychange', () => {
    if (document.hidden && stream) { stream.getTracks().forEach(t => t.stop()); running = false; }
  });
})();
</script>
</body>
</html>